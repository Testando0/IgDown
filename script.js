Document.addEventListener("DOMContentLoaded", () => {
    
    // Seleciona os elementos do HTML
    const form = document.getElementById("download-form");
    const urlInput = document.getElementById("url-input");
    const downloadButton = document.getElementById("download-button");
    const buttonText = downloadButton.querySelector(".button-text");
    const buttonLoader = downloadButton.querySelector(".button-loader");
    const messageArea = document.getElementById("message-area");
    const resultArea = document.getElementById("result-area");
    
    const platformSelect = document.getElementById("platform-select");

    // Adiciona um "ouvinte" para o evento de submit do formul√°rio
    form.addEventListener("submit", async (event) => {
        event.preventDefault(); 
        
        const userUrl = urlInput.value.trim();
        const platform = platformSelect.value; 

        // 1. Valida√ß√£o simples
        if (!userUrl) {
            showMessage("Por favor, insira um URL.", "error");
            return;
        }

        // 2. Iniciar o estado de carregamento
        setLoading(true);
        showMessage("Conectando aos servidores... ‚òÅÔ∏è", "loading");
        resultArea.innerHTML = ""; // Limpa resultados anteriores

        // 3. L√≥gica de sele√ß√£o de plataforma
        try {
            switch (platform) {
                case "instagram":
                    if (!userUrl.includes("instagram.com")) {
                        throw new Error("Este n√£o parece ser um link v√°lido do Instagram.");
                    }
                    await downloadInstagram(userUrl);
                    break;
                
                case "tiktok":
                    if (!userUrl.includes("tiktok.com")) {
                        throw new Error("Este n√£o parece ser um link v√°lido do TikTok.");
                    }
                    await downloadTikTok(userUrl);
                    break;

                case "threads":
                    if (!userUrl.includes("threads.net")) {
                         throw new Error("Este n√£o parece ser um link v√°lido do Threads.");
                    }
                    await downloadThreads(userUrl); // Chama a fun√ß√£o corrigida
                    break;
                
                default:
                    throw new Error("Plataforma desconhecida ou ainda n√£o suportada.");
            }

        } catch (error) {
            // 7. Tratar erros
            console.error(error); 
            setLoading(false);
            showMessage(error.message || "Oops! Algo deu errado. Tente novamente.", "error");
            resultArea.innerHTML = "";
        }
    });

    /**
     * Fun√ß√£o para cuidar do download do Instagram
     */
    async function downloadInstagram(userUrl) {
        const apiUrl = `https://api.nexfuture.com.br/api/downloads/instagram/mp4?url=${encodeURIComponent(userUrl)}`;
        
        const response = await fetch(apiUrl);

        if (!response.ok) {
            throw new Error(`Falha na API (IG). Link inv√°lido ou offline? (Status: ${response.status})`);
        }

        const videoBlob = await response.blob();

        if (!videoBlob.type.startsWith('video/')) {
            throw new Error("A API (IG) n√£o retornou um v√≠deo. O link pode ser privado ou inv√°lido.");
        }

        const videoUrl = URL.createObjectURL(videoBlob);

        setLoading(false); 
        showMessage(""); 
        
        const filename = `video-ig-${Date.now()}.mp4`; 
        
        resultArea.innerHTML = `
            <a href="${videoUrl}" class="download-link" download="${filename}">
                Download Conclu√≠do! Clique aqui ‚ù§Ô∏è
            </a>
        `;
    }

    /**
     * Fun√ß√£o para cuidar do download do TikTok
     */
    async function downloadTikTok(userUrl) {
        const apiUrl = `https://api.nexfuture.com.br/api/downloads/tiktok/mp4?url=${encodeURIComponent(userUrl)}`;
        
        const response = await fetch(apiUrl);

        if (!response.ok) {
            throw new Error(`Falha na API (TT). Link inv√°lido ou offline? (Status: ${response.status})`);
        }

        const videoBlob = await response.blob();

        if (!videoBlob.type.startsWith('video/')) {
            throw new Error("A API (TT) n√£o retornou um v√≠deo. O link pode ser privado ou inv√°lido.");
        }

        const videoUrl = URL.createObjectURL(videoBlob);

        setLoading(false); 
        showMessage(""); 
        
        const filename = `video-tt-${Date.now()}.mp4`; 
        
        resultArea.innerHTML = `
            <a href="${videoUrl}" class="download-link" download="${filename}">
                Download Conclu√≠do! Clique aqui ‚ù§Ô∏è
            </a>
        `;
    }

    /**
     * NOVO: Fun√ß√£o para cuidar do download do Threads (Corrigida com Proxy CORS)
     */
    async function downloadThreads(userUrl) {
        
        // 1. URL da API que retorna o JSON com os links
        const apiUrl = `https://world-ecletix.onrender.com/api/threads2?url=${encodeURIComponent(userUrl)}`;
        
        // 2. Usamos um proxy CORS (allorigins.win) para conseguir chamar a API 'world-ecletix'
        //    O 'api.allorigins.win/raw?url=' baixa o conte√∫do da URL fornecida
        const proxyApiUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(apiUrl)}`;

        showMessage("Conectando ao proxy da API... üì° (1/3)", "loading");
        
        let apiResponse;
        try {
            // Tenta buscar o JSON da API do Threads atrav√©s do proxy
            apiResponse = await fetch(proxyApiUrl);
        } catch (e) {
            throw new Error("Falha ao conectar no proxy CORS. Verifique a conex√£o ou o proxy.");
        }

        if (!apiResponse.ok) {
            throw new Error(`Falha na API (Threads) via Proxy. (Status: ${apiResponse.status})`);
        }

        const data = await apiResponse.json();

        // 3. Valida√ß√£o da resposta da API (baseado no seu 'case' original)
        if (!data || data.statusCode !== 200 || !data.resultado || !Array.isArray(data.resultado.resultado) || data.resultado.resultado.length === 0) {
            throw new Error("Nenhuma m√≠dia encontrada ou resposta inv√°lida da API do Threads.");
        }

        const midias = data.resultado.resultado;
        resultArea.innerHTML = ""; // Limpa √°rea de resultados
        showMessage(`M√≠dia(s) encontrada(s): ${midias.length}. Baixando... ‚è≥ (2/3)`, "loading");

        let mediaCount = 0;
        
        // 4. Iteramos por cada m√≠dia encontrada (v√≠deo ou imagem de um carrossel, por ex.)
        for (const item of midias) {
            const mediaUrl = item.link; // Este √© o link direto para o cdn.facebook.com/...
            if (!mediaUrl) continue;
            
            mediaCount++;
            showMessage(`Baixando item ${mediaCount}/${midias.length}...`, "loading");

            try {
                // 5. USAMOS O PROXY DE NOVO!
                // Desta vez, para baixar o *arquivo* (v√≠deo/imagem) que est√° no CDN
                const mediaProxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(mediaUrl)}`;

                const mediaResponse = await fetch(mediaProxyUrl);
                
                if (!mediaResponse.ok) {
                    throw new Error(`Falha ao baixar m√≠dia do item ${mediaCount}`);
                }

                // 6. Pegamos o Blob (o arquivo em si)
                const mediaBlob = await mediaResponse.blob();

                // 7. Criamos um Object URL local (Exatamente como nas fun√ß√µes do IG e TT)
                //    Isso permite que o atributo 'download' funcione
                const blobUrl = URL.createObjectURL(mediaBlob);
                
                // Detecta o tipo e define o nome do arquivo
                const isVideo = mediaBlob.type.startsWith('video/');
                const extension = isVideo ? 'mp4' : 'jpg'; // Suposi√ß√£o simples
                const filename = `media-threads-${Date.now()}-${mediaCount}.${extension}`;

                // 8. Criar o link de download final
                const linkElement = document.createElement('a');
                linkElement.href = blobUrl;
                linkElement.className = "download-link";
                linkElement.download = filename; // Agora o 'download' funciona!
                linkElement.textContent = `Download ${isVideo ? 'V√≠deo' : 'Imagem'} ${mediaCount} ‚ù§Ô∏è`;
                
                resultArea.appendChild(linkElement); // Adiciona o link √† √°rea de resultados
                
            } catch (err) {
                console.error(err);
                // Se um item falhar, mostra um erro mas continua para o pr√≥ximo
                const errorElement = document.createElement('p');
                errorElement.textContent = `Falha ao baixar item ${mediaCount}.`;
                errorElement.className = "error-message";
                resultArea.appendChild(errorElement);
            }
        }
        
        if (mediaCount === 0) {
             throw new Error("API respondeu, mas n√£o foi poss√≠vel extrair m√≠dias v√°lidas.");
        }

        // 9. Sucesso
        setLoading(false);
        showMessage("Downloads prontos! (3/3)", ""); // Limpa mensagem de loading

    }


    // Fun√ß√£o para ligar/desligar o estado de carregamento do bot√£o
    function setLoading(isLoading) {
        if (isLoading) {
            downloadButton.disabled = true;
            buttonText.style.display = "none";
            buttonLoader.style.display = "block";
        } else {
            downloadButton.disabled = false;
            buttonText.style.display = "block";
            buttonLoader.style.display = "none";
        }
    }

    // Fun√ß√£o para mostrar mensagens ao usu√°rio
    function showMessage(message, type = "") {
        messageArea.textContent = message;
        if (type === "error") {
            messageArea.className = "error-message";
        } else if (type === "loading") {
            messageArea.className = "loading-message";
        } else {
            messageArea.className = "";
        }
    }
});
